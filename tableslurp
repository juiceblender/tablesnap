#!/usr/bin/env python
#
# -*- mode:python; sh-basic-offset:4; indent-tabs-mode:nil; coding:utf-8 -*-
# vim:set tabstop=4 softtabstop=4 expandtab shiftwidth=4 fileencoding=utf-8:
#
# Copyright (c) 2012, Jorge A Gallegos <kad@blegh.net>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

import argparse
import boto
from dateutil import parser
import grp
import json
import logging
import threading
import os
import pwd
import socket
import sys
from Queue import Queue

log = logging.getLogger('tableslurp')
stderr = logging.StreamHandler()
stderr.setFormatter(logging.Formatter(
    '%(name)s [%(asctime)s] %(levelname)s %(message)s'))
log.addHandler(stderr)
if os.environ.get('TDEBUG', False):
    log.setLevel(logging.DEBUG)
else:
    log.setLevel(logging.INFO)

def get_bucket(region, key, secret, token, bucket_name):
#   unsure if boto is thread-safe, will reconnect every time
    log.debug('Connecting to s3')
    if token:
        conn = boto.s3.connect_to_region(region,
                                         aws_access_key_id=key,
                                         aws_secret_access_key=secret,
                                         security_token=token)
    else:
        conn = boto.s3.connect_to_region(region,
                                         aws_access_key_id=key,
                                         aws_secret_access_key=secret,
                                         security_token=token)

    bucket = conn.get_bucket(bucket_name)
    log.debug('Connected to s3')
    return bucket

class DownloadCounter(object):
    filename = None
    attemptcount = 0

    def __init__(self, filename):
        self.filename = filename

    def increment(self):
        self.attemptcount += 1


class DownloadHandler(object):
    def __init__(self, key=None, secret=None, region=None, token=None, bucket_name=None,
                 owner=None, group=None, preserve=False, target=None, prefix=None,
                 force=False, name=socket.getfqdn(), fileset=None, num_threads=4):
        self.target = target
        self.preserve = preserve
        self.key = key
        self.secret = secret
        self.region = region
        self.token = token
        self.bucket_name = bucket_name
        self.num_threads = num_threads
        self.force = force
        self.name = name
        self.prefix = prefix
        self.fileset=fileset
        self.queue = Queue()
        self.threads={}

#       It may be a bit sub-optimal, but I rather fail sooner than later
        (o, g) = self._check_metadata()

        if not preserve:
            o = owner
            g = group

        try:
            self.owner = pwd.getpwnam(o).pw_uid
            self.group = grp.getgrnam(g).gr_gid
        except Exception as e:
            log.error(e)
            raise OSError('User/Group pair %s:%s does not exist' %
                (owner, group,))

    def _get_bucket(self):
        return get_bucket(self.region, self.key, self.secret, self.token, self.bucket_name)

    def _check_metadata(self):
        bucket = self._get_bucket()
        for fileset in self.fileset:
            k = bucket.get_key('%s/%s' % (self.prefix, fileset))
            if k is not None:
                break

#       The librato branch introduced this
        owner = None
        group = None

        if k is None:
            log.warn('Can not fetch metadata information')
            return (owner, group)

        meta = k.get_metadata('stat')
        log.debug('Metadata is %s' % (meta,))
        if meta:
            try:
                json_data = json.loads(meta)
                owner = json_data['user']
                group = json_data['group']
            except TypeError as te:
                log.debug(te)
                log.warning('Could not parse stat metadata for %s' % (k.name,))
            except KeyError as ke:
                log.debug(ke)
                log.warning('Incomplete stat metadata for %s, will ignore' %
                    (k.name,))
        return (owner, group)

    def _test_permissions(self):
        log.info('Will now try to test writing to the target dir %s' %
            (self.target,))
        try:

            if os.path.isdir(self.target) == False:
                log.debug('Creating temp file in %s' % (self.target,))
                os.makedirs(self.target)
            log.debug('Changing owner:group for %s to %s:%s' %
                (self.target, self.owner, self.group,))

            os.chown(self.target, self.owner, self.group)
        except Exception as e:
            log.debug(e)
            log.exception('%s exists' % (self.target,))
        log.info('Will write to %s' % (self.target,))

    def _worker(self, idx, queue):
        log.info('Thread #%d processing items' % (idx, ))
        bucket = self._get_bucket()

        while queue.empty() == False:
            queueddownload = queue.get()
            fname = queueddownload.filename
            keypath = '%s/%s' % (self.prefix, fname,)
            destfile = os.path.join(self.target, os.path.basename(fname))

            log.debug('Checking if we need to download %s to %s' %
                (keypath, destfile,))

            if queueddownload.attemptcount < 5:
                download = False
                #Retry downloading until we succeed
                try:
                    key = bucket.get_key(keypath)
                    log.debug('Key object is %s' % key)
                    if os.path.isfile(destfile):
                        stat = os.stat(destfile)
                        if self.force:
                            download = True
                        elif stat.st_size != key.size:
                            log.info('%s and %s size differs, will '
                                're-download' % (key.name, destfile,))
                            download = True
                    else:
                        download = True

                    if download and key:
                        log.info('Downloading %s from %s to %s' %
                            (key.name, bucket.name, destfile))
                        key.get_contents_to_filename(destfile)

                        log.debug('Changing owner:group for %s to %s:%s' %
                            (destfile, self.owner, self.group,))
                        os.chown(destfile, self.owner, self.group)

                except Exception as e:
                    log.debug(e)
                    log.exception('Failed to download `%s` retrying' %
                        (fname,))
                    #We can't download, try again
                    queueddownload.increment()
                    queue.put(queueddownload)

            else:
                log.info('Tried to download %s too many times.  Giving up' %
                    fname)

            #Pop the task regardless of state.  If it fails we've put it back
            queue.task_done()

        log.info('Thread #%d finished processing' % (idx,))

    def run(self):
        self._test_permissions()
        log.info('Running')

        #queue up the filesets
        for filename in self.fileset:
            log.info('Pushing file %s onto queue' % filename)
            self.queue.put(DownloadCounter(filename))

#       launch threads and attach an event to them
        for idx in range(0, self.num_threads):
            self.threads[idx] = {}
#            e = threading.Event()
            t = threading.Thread(target=self._worker,
                kwargs={'idx': idx, 'queue': self.queue})
            t.setDaemon(True)
            self.threads[idx] = t
            t.start()

        #Wait for everything to finish downloading
        self.queue.join()
        log.info('My job is done.')


def main():
    p = pwd.getpwnam(os.environ['USER'])
    owner = p.pw_name
    group = [_.gr_name for _ in grp.getgrall() if _.gr_gid == p.pw_gid][0]
    ap = argparse.ArgumentParser(
        description='This is the companion script to the `tablesnap` program '
        'which you can use to restore files from an Amazon S3 bucket to any '
        'given local directory which you have write-permissions on. While the '
        'code is straightforward, the program assumes the files you are '
        'restoring got previously backed up with `tablesnap`',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    ap.add_argument('-k', '--aws-key',
        default=os.environ.get('AWS_ACCESS_KEY_ID'),
        help='Amazon S3 Key (default from AWS_ACCESS_KEY_ID in environment)')
    ap.add_argument('-s', '--aws-secret',
        default=os.environ.get('AWS_SECRET_ACCESS_KEY'),
        help='Amazon S3 Secret (default from AWS_SECRET_ACCESS_KEY in environment)')
    ap.add_argument('--token',
        default=os.environ.get('AWS_SECURITY_TOKEN'),
        help='Amazon S3 Token (default from AWS_SECURITY_TOKEN in environment)')
    ap.add_argument('--aws-region',
        default='us-east-1',
        choices=[region.name for region in boto.s3.regions()],
        help='AWS region to connect to.')
    ap.add_argument('-p', '--preserve', default=False, action='store_true',
        help='Preserve the permissions (if they exist) from the source. '
        'This overrides -o and -g')
    ap.add_argument('-o', '--owner', default=owner,
        help='After download, chown files to this user.')
    ap.add_argument('-g', '--group', default=group,
        help='After download, chgrp files to this group.')
    ap.add_argument('-t', '--threads', type=int, default=4,
        help='Split the download between this many threads')
    ap.add_argument('-f', '--file',
        help='If specified, will download the file-set this file belongs to '
        'instead of the latest one available.')
    ap.add_argument('--force', default=False, action='store_true',
        help='Force download files even if they exist')
    ap.add_argument('-n', '--name', default=socket.getfqdn(),
        help='Use this name instead of the FQDN to prefix the bucket dir')
    ap.add_argument('bucket', nargs=1,
        help='S3 bucket to download files from')
    ap.add_argument('origin', nargs=1,
        help='Path inside the bucket to the directory you want to download '
        'files from')
    ap.add_argument('-r', '--recursive', default=False, action='store_true',
        help='Recursively download the files at the given directory')
    ap.add_argument('target', nargs=1,
        help='Path in the local FS where files should be downloaded to')
    args = ap.parse_args()

    prefix='%s:%s' % (args.name, args.origin[0])
    bucket=get_bucket(args.aws_region, args.aws_key, args.aws_secret, args.token, args.bucket[0])
    log.info('Building fileset')
    if args.recursive:
        table_to_files_mapping={}
        keyspace_dirs = [_.name for _ in list(bucket.list(prefix='%s/' % prefix, delimiter='/'))]

        for keyspace_dir in keyspace_dirs:
            table_dirs = [_.name for _ in list(bucket.list(prefix=keyspace_dir, delimiter='/'))]

            for table_dir in table_dirs:
                keys = [_ for _ in bucket.list(prefix=table_dir, delimiter='/') if _.name.endswith('-listdir.json')]

                if keys:
                    keys.sort(key=lambda l: parser.parse(l.last_modified))
                    key = keys.pop()
                    json_data = json.loads(key.get_contents_as_string())
                    # There should only ever be one latest listdir.json and hence, one set of SSTables
                    sstables = json_data.itervalues().next()
                    table = table_dir.replace('%s/' % prefix, '').rstrip('/')
                    table_to_files_mapping[table] = sstables
                    log.info("Found %s with %d files", table, len(sstables))
        for k,v in table_to_files_mapping.iteritems():
            dh = DownloadHandler(key=args.aws_key, secret=args.aws_secret, token=args.token, region=args.aws_region,
                                 bucket_name=args.bucket[0], owner=args.owner, group=args.group, preserve=args.preserve,
                                 target=os.path.join(args.target[0], k), prefix=os.path.join(prefix, k),
                                 force=args.force, name=args.name, fileset=v, num_threads=args.threads)
            dh.run()
    else:
        key = None
        # If you want to restore a file-set in particular
        if args.file:
            key = bucket.get_key('%s/%s-listdir.json' %
                                 (prefix, args.file))

        else:
            prefix_part_count = prefix.count('/') + 1
            keys = [_ for _ in bucket.list(prefix='%s/' %
                                                  (prefix,)) if
                    _.name.endswith('-listdir.json') and _.name.count('/') == prefix_part_count]
            if keys:
                keys.sort(key=lambda l: parser.parse(l.last_modified))
                key = keys.pop()

        if not key:
            raise LookupError('Cannot find anything to restore from %s:%s/%s' %
                              (bucket.name, prefix, args.target_file or ''))

        json_data = json.loads(key.get_contents_as_string())
        fileset = json_data[args.origin[0]]
        log.info('Fileset contains %d files to download' % (len(fileset)))
        dh = DownloadHandler(key=args.aws_key, secret=args.aws_secret, token=args.token, region=args.aws_region,
                             bucket_name=args.bucket[0], owner=args.owner, group=args.group, preserve=args.preserve,
                             target=args.target[0], prefix=prefix, force=args.force, name=args.name,
                             fileset=fileset, num_threads=args.threads)
        dh.run()

if __name__ == '__main__':
    sys.exit(main())
